diff --git 0.2.8.orig/features/thin_check.feature 0.2.8/features/thin_check.feature
index 3b896a1..8b910af 100644
--- 0.2.8.orig/features/thin_check.feature
+++ 0.2.8/features/thin_check.feature
@@ -17,9 +17,10 @@ Feature: thin_check
       {-q|--quiet}
       {-h|--help}
       {-V|--version}
-      {--super-block-only}
-      {--skip-mappings}
+      {--clear-needs-check-flag}
       {--ignore-non-fatal-errors}
+      {--skip-mappings}
+      {--super-block-only}
     """
 
   Scenario: print help
@@ -32,9 +33,10 @@ Feature: thin_check
       {-q|--quiet}
       {-h|--help}
       {-V|--version}
-      {--super-block-only}
-      {--skip-mappings}
+      {--clear-needs-check-flag}
       {--ignore-non-fatal-errors}
+      {--skip-mappings}
+      {--super-block-only}
     """
 
   Scenario: Unrecognised option should cause failure
@@ -77,3 +79,8 @@ Feature: thin_check
     When I run thin_check with --quiet
     Then it should fail
     And it should give no output
+
+  Scenario: Accepts --clear-needs-check-flag
+    Given valid metadata
+    When I run thin_check with --clear-needs-check-flag
+    Then it should pass
diff --git 0.2.8.orig/thin-provisioning/superblock.cc 0.2.8/thin-provisioning/superblock.cc
index b89ac64..4412696 100644
--- 0.2.8.orig/thin-provisioning/superblock.cc
+++ 0.2.8/thin-provisioning/superblock.cc
@@ -113,6 +113,23 @@ thin_provisioning::superblock_validator()
 
 namespace thin_provisioning {
 	namespace superblock_detail {
+		namespace {
+			unsigned const NEEDS_CHECK_BIT = 0;
+		}
+
+		bool
+		superblock::get_needs_check_flag() const {
+			return flags_ & (1 << NEEDS_CHECK_BIT);
+		}
+
+		void
+		superblock::set_needs_check_flag(bool val) {
+			if (val)
+				flags_ |= (1 << NEEDS_CHECK_BIT);
+			else
+				flags_ &= ~(1 << NEEDS_CHECK_BIT);
+		};
+
 		superblock_corruption::superblock_corruption(std::string const &desc)
 			: desc_(desc) {
 		}
@@ -144,6 +161,13 @@ namespace thin_provisioning {
 		return read_superblock(bm, SUPERBLOCK_LOCATION);
 	}
 
+	void write_superblock(block_manager<>::ptr bm, superblock_detail::superblock const &sb)
+	{
+		block_manager<>::write_ref w = bm->write_lock(SUPERBLOCK_LOCATION, superblock_validator());
+		superblock_disk *disk = reinterpret_cast<superblock_disk *>(w.data().raw());
+		superblock_traits::pack(sb, *disk);
+	}
+
 	void
 	check_superblock(block_manager<>::ptr bm,
 			 superblock_detail::damage_visitor &visitor) {
diff --git 0.2.8.orig/thin-provisioning/superblock.h 0.2.8/thin-provisioning/superblock.h
index d6d78e3..b997c0a 100644
--- 0.2.8.orig/thin-provisioning/superblock.h
+++ 0.2.8/thin-provisioning/superblock.h
@@ -80,6 +80,9 @@ namespace thin_provisioning {
 			uint32_t compat_flags_;
 			uint32_t compat_ro_flags_;
 			uint32_t incompat_flags_;
+
+			bool get_needs_check_flag() const;
+			void set_needs_check_flag(bool val = true);
 		};
 
 		struct superblock_traits {
@@ -125,7 +128,12 @@ namespace thin_provisioning {
 	// FIXME: should we put init_superblock in here too?
 
 	superblock_detail::superblock read_superblock(persistent_data::block_manager<>::ptr bm);
-	superblock_detail::superblock read_superblock(persistent_data::block_manager<>::ptr bm, persistent_data::block_address location);
+	superblock_detail::superblock read_superblock(persistent_data::block_manager<>::ptr bm,
+						      persistent_data::block_address location);
+
+	void write_superblock(persistent_data::block_manager<>::ptr bm,
+			      superblock_detail::superblock const &sb);
+
 	void check_superblock(persistent_data::block_manager<>::ptr bm,
 			      superblock_detail::damage_visitor &visitor);
 }
diff --git 0.2.8.orig/thin-provisioning/thin_check.cc 0.2.8/thin-provisioning/thin_check.cc
index ea5e56e..e468a02 100644
--- 0.2.8.orig/thin-provisioning/thin_check.cc
+++ 0.2.8/thin-provisioning/thin_check.cc
@@ -148,6 +148,15 @@ namespace {
 	//--------------------------------
 
 	struct flags {
+		flags()
+			: check_device_tree(true),
+			  check_mapping_tree_level1(true),
+			  check_mapping_tree_level2(true),
+			  ignore_non_fatal_errors(false),
+			  quiet(false),
+			  clear_needs_check_flag_on_success(false) {
+		}
+
 		bool check_device_tree;
 		bool check_mapping_tree_level1;
 		bool check_mapping_tree_level2;
@@ -155,6 +164,7 @@ namespace {
 		bool ignore_non_fatal_errors;
 
 		bool quiet;
+		bool clear_needs_check_flag_on_success;
 	};
 
 	error_state metadata_check(string const &path, flags fs) {
@@ -214,12 +224,31 @@ namespace {
 						     dev_rep.get_error()));
 	}
 
+	void clear_needs_check(string const &path) {
+		block_manager<>::ptr bm = open_bm(path, block_io<>::READ_WRITE);
+
+		superblock_detail::superblock sb = read_superblock(bm);
+		sb.set_needs_check_flag(false);
+		write_superblock(bm, sb);
+	}
+
+	// Returns 0 on success, 1 on failure (this gets returned directly
+	// by main).
 	int check(string const &path, flags fs) {
 		error_state err;
+		bool success = false;
 
 		try {
 			err = metadata_check(path, fs);
 
+			if (fs.ignore_non_fatal_errors)
+				success = (err == FATAL) ? 1 : 0;
+			else
+				success =  (err == NO_ERROR) ? 0 : 1;
+
+			if (!success && fs.clear_needs_check_flag_on_success)
+				clear_needs_check(path);
+
 		} catch (std::exception &e) {
 			if (!fs.quiet)
 				cerr << e.what() << endl;
@@ -227,10 +256,7 @@ namespace {
 			return 1;
 		}
 
-		if (fs.ignore_non_fatal_errors)
-			return (err == FATAL) ? 1 : 0;
-		else
-			return (err == NO_ERROR) ? 0 : 1;
+		return success;
 	}
 
 	void usage(ostream &out, string const &cmd) {
@@ -239,9 +265,10 @@ namespace {
 		    << "  {-q|--quiet}" << endl
 		    << "  {-h|--help}" << endl
 		    << "  {-V|--version}" << endl
-		    << "  {--super-block-only}" << endl
+		    << "  {--clear-needs-check-flag}" << endl
+		    << "  {--ignore-non-fatal-errors}" << endl
 		    << "  {--skip-mappings}" << endl
-		    << "  {--ignore-non-fatal-errors}" << endl;
+		    << "  {--super-block-only}" << endl;
 	}
 }
 
@@ -249,11 +276,6 @@ int main(int argc, char **argv)
 {
 	int c;
 	flags fs;
-	fs.check_device_tree = true;
-	fs.check_mapping_tree_level1 = true,
-	fs.check_mapping_tree_level2 = true,
-	fs.ignore_non_fatal_errors = false,
-	fs.quiet = false;
 
 	char const shortopts[] = "qhV";
 	option const longopts[] = {
@@ -263,6 +285,7 @@ int main(int argc, char **argv)
 		{ "super-block-only", no_argument, NULL, 1},
 		{ "skip-mappings", no_argument, NULL, 2},
 		{ "ignore-non-fatal-errors", no_argument, NULL, 3},
+		{ "clear-needs-check-flag", no_argument, NULL, 4 },
 		{ NULL, no_argument, NULL, 0 }
 	};
 
@@ -297,6 +320,11 @@ int main(int argc, char **argv)
 			fs.ignore_non_fatal_errors = true;
 			break;
 
+		case 4:
+			// clear needs-check flag
+			fs.clear_needs_check_flag_on_success = true;
+			break;
+
 		default:
 			usage(cerr, basename(argv[0]));
 			return 1;
-- 
1.9.0

